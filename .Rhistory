D<-results$Dssh[which(results$combination==i)]
model<-lm(s~D)
correlations[b]<-sum((fitted(model)-s)^2) # calculate SSE
slopes[b]<-model$coefficients[2]
b<-b+1
}
correlations<-cbind.data.frame(levels(results$combination),correlations,slopes) # put results into one datasets, using just cbind would make it all character as the first vector
correlations<-correlations[correlations[,3]<0,]# remove negative correlations
location<-correlations[which(correlations[,2]==min(correlations[,2])),1] # saves the locations of OH and OL
origins<-as.numeric(c(substr(location,start=regexpr("OH",location)+2,stop=regexpr("OL",location)-1),substr(location,start=regexpr("OL",location)+2,stop=nchar(location))))
# in the paper, they analyzed the H strand but needed to return coordinates on the L strand, so I assume that I must switch the values in the end to get correct coordinates
#summarize results
names(origins)<-c("OL","OH")
print(alignment[1])
print(paste0("OH: ",origins[2]," OL: ",origins[1]))
return(c(origins[2],origins[1]))
plot(skews)
epication_origin<-function(alignment,window){
# preparing the data
if(is.data.frame(alignment)==TRUE){alignment<-alignment[,1,drop=TRUE]}
# in the cited paper, they used alignments; here we tried it also sequence by sequence and examined the distributions of the inferred OH and OL positions
#alignment.source<-alignment
#alignment.nogaps<-alignment
#alignment.nogaps[seq(from=2,to=length(alignment),by=2)]<-gsub("-",replacement="",alignment[seq(from=2,to=length(alignment),by=2)])
#for (j in seq(from=1,to=length(alignment.source),by=2)){
#alignment<-alignment.nogaps[j:(j+1)]
# create windows (they used 250, but an odd number has a clearly defined middle nucleotide)
windows<-seq(from=(window%/%2)+1,to=nchar(alignment[2]),by=window)
nwindows<-length(windows)
# iterate over windows, calculate GC skew
# in Deuterostomes, most genes are coded on the L strand, so that is the strand in sequence databases and the one they calculated the GC skew for
# in land snails, most genes are coded on the H strand, so our alignments are also the H strand
# we thus calculate the complementary GC skew, to calculate it for the L strand like in the cited paper
skews<-numeric()
for (i in 1:nwindows){
#extract sequences within window, count Cs and Gs
strings<-substr(alignment[seq(from=2,to=length(alignment),by=2)],windows[i]-(window%/%2),windows[i]+(window%/%2))
Gs<-lengths(regmatches(strings, gregexpr("G", strings)))
Cs<-lengths(regmatches(strings, gregexpr("C", strings)))
# GC skew = (G − C)/(G + C) for the L strand, we work with the H strand
skew<-(sum(Cs)-sum(Gs))/(sum(Gs)+sum(Cs))
skews[i]<-skew
} # end iterating over windows
#specify the formula to calculate Dssh
formula<-function(OL,OH, p, L, windows){
# the mitogenome is circular... this situation needs a fake coordinate system with respect to OH to calculate the distances
# OH, OL, and p can only take values specified in windows
offset<-OH-min(windows) # offset is by how much is OH shifted with respect to the starting OH
OH<-min(windows) # we put OH at position 1 in windows
if(OL<OH){OL<-OL-offset+max(windows)}else{OL<-OL-offset}
if(p<=OH){p<-p-offset+max(windows)}else{p<-p-offset}
if((p-OH)<=(OL-OH)){Dssh<-((2*(OL-p))/L)} #checked
if((p-OH)>(OL-OH)&(OL-OH)<L/2){Dssh<-((2*(p-OH))/L)} #result must be positive, so OH-p would not work
if((p-OH)>(OL-OH)&(OL-OH)>=L/2){Dssh<-((L-(2*(p-OL)))/L)} #checked
return(Dssh)
}
# prepare variables
L<-nchar(alignment[2])
results<-matrix(nrow=(nwindows*nwindows*(nwindows-1)),ncol=5)
combination<-character(length=(nwindows*nwindows*(nwindows-1)))
#calculate the Dssh for each OH and OL combination and all genome positions
a<-1
for(p in windows){
for(OH in windows){
for(OL in windows[which(windows!=OH)]){
Dssh<-formula(p=p,OH=OH,OL=OL,L=L,windows=windows)
results[a,1]<-p
results[a,2]<-skews[which(windows==(p))]
results[a,3]<-OH
results[a,4]<-OL
results[a,5]<-Dssh
combination[a]<-paste0("OH",OH,"OL",OL)
a<-a+1
}
}
}
# put results in one data.frame
results<-cbind.data.frame(results,combination,stringsAsFactors = TRUE)
colnames(results)<-c("p","skew","OH","OL","Dssh","combination")
# for each OH and OL combination, get the SSE and slope
correlations<-numeric(length=length(levels(results$combination)))
slopes<-numeric(length=length(levels(results$combination)))
b<-1
for(i in levels(results$combination)){
s<-results$skew[which(results$combination==i)]
D<-results$Dssh[which(results$combination==i)]
model<-lm(s~D)
correlations[b]<-sum((fitted(model)-s)^2) # calculate SSE
slopes[b]<-model$coefficients[2]
b<-b+1
}
correlations<-cbind.data.frame(levels(results$combination),correlations,slopes) # put results into one datasets, using just cbind would make it all character as the first vector
correlations<-correlations[correlations[,3]<0,]# remove negative correlations
location<-correlations[which(correlations[,2]==min(correlations[,2])),1] # saves the locations of OH and OL
origins<-as.numeric(c(substr(location,start=regexpr("OH",location)+2,stop=regexpr("OL",location)-1),substr(location,start=regexpr("OL",location)+2,stop=nchar(location))))
# in the paper, they analyzed the H strand but needed to return coordinates on the L strand, so I assume that I must switch the values in the end to get correct coordinates
#summarize results
names(origins)<-c("OL","OH")
print(alignment[1])
print(paste0("OH: ",origins[2]," OL: ",origins[1]))
return(c(origins[2],origins[1]))
# } #end of iteration over sequences, see lines just below data loading
} # end of function
results<-numeric(lenght=2)
results<-numeric(length =2)
for(i in seq(151,351,by=10)){
results<-rbind(results,replication_origin(alignment,i))
}
replication_origin<-function(alignment,window){
# preparing the data
if(is.data.frame(alignment)==TRUE){alignment<-alignment[,1,drop=TRUE]}
# in the cited paper, they used alignments; here we tried it also sequence by sequence and examined the distributions of the inferred OH and OL positions
#alignment.source<-alignment
#alignment.nogaps<-alignment
#alignment.nogaps[seq(from=2,to=length(alignment),by=2)]<-gsub("-",replacement="",alignment[seq(from=2,to=length(alignment),by=2)])
#for (j in seq(from=1,to=length(alignment.source),by=2)){
#alignment<-alignment.nogaps[j:(j+1)]
# create windows (they used 250, but an odd number has a clearly defined middle nucleotide)
windows<-seq(from=(window%/%2)+1,to=nchar(alignment[2]),by=window)
nwindows<-length(windows)
# iterate over windows, calculate GC skew
# in Deuterostomes, most genes are coded on the L strand, so that is the strand in sequence databases and the one they calculated the GC skew for
# in land snails, most genes are coded on the H strand, so our alignments are also the H strand
# we thus calculate the complementary GC skew, to calculate it for the L strand like in the cited paper
skews<-numeric()
for (i in 1:nwindows){
#extract sequences within window, count Cs and Gs
strings<-substr(alignment[seq(from=2,to=length(alignment),by=2)],windows[i]-(window%/%2),windows[i]+(window%/%2))
Gs<-lengths(regmatches(strings, gregexpr("G", strings)))
Cs<-lengths(regmatches(strings, gregexpr("C", strings)))
# GC skew = (G − C)/(G + C) for the L strand, we work with the H strand
skew<-(sum(Cs)-sum(Gs))/(sum(Gs)+sum(Cs))
skews[i]<-skew
} # end iterating over windows
#specify the formula to calculate Dssh
formula<-function(OL,OH, p, L, windows){
# the mitogenome is circular... this situation needs a fake coordinate system with respect to OH to calculate the distances
# OH, OL, and p can only take values specified in windows
offset<-OH-min(windows) # offset is by how much is OH shifted with respect to the starting OH
OH<-min(windows) # we put OH at position 1 in windows
if(OL<OH){OL<-OL-offset+max(windows)}else{OL<-OL-offset}
if(p<=OH){p<-p-offset+max(windows)}else{p<-p-offset}
if((p-OH)<=(OL-OH)){Dssh<-((2*(OL-p))/L)} #checked
if((p-OH)>(OL-OH)&(OL-OH)<L/2){Dssh<-((2*(p-OH))/L)} #result must be positive, so OH-p would not work
if((p-OH)>(OL-OH)&(OL-OH)>=L/2){Dssh<-((L-(2*(p-OL)))/L)} #checked
return(Dssh)
}
# prepare variables
L<-nchar(alignment[2])
results<-matrix(nrow=(nwindows*nwindows*(nwindows-1)),ncol=5)
combination<-character(length=(nwindows*nwindows*(nwindows-1)))
#calculate the Dssh for each OH and OL combination and all genome positions
a<-1
for(p in windows){
for(OH in windows){
for(OL in windows[which(windows!=OH)]){
Dssh<-formula(p=p,OH=OH,OL=OL,L=L,windows=windows)
results[a,1]<-p
results[a,2]<-skews[which(windows==(p))]
results[a,3]<-OH
results[a,4]<-OL
results[a,5]<-Dssh
combination[a]<-paste0("OH",OH,"OL",OL)
a<-a+1
}
}
}
# put results in one data.frame
results<-cbind.data.frame(results,combination,stringsAsFactors = TRUE)
colnames(results)<-c("p","skew","OH","OL","Dssh","combination")
# for each OH and OL combination, get the SSE and slope
correlations<-numeric(length=length(levels(results$combination)))
slopes<-numeric(length=length(levels(results$combination)))
b<-1
for(i in levels(results$combination)){
s<-results$skew[which(results$combination==i)]
D<-results$Dssh[which(results$combination==i)]
model<-lm(s~D)
correlations[b]<-sum((fitted(model)-s)^2) # calculate SSE
slopes[b]<-model$coefficients[2]
b<-b+1
}
correlations<-cbind.data.frame(levels(results$combination),correlations,slopes) # put results into one datasets, using just cbind would make it all character as the first vector
correlations<-correlations[correlations[,3]<0,]# remove negative correlations
location<-correlations[which(correlations[,2]==min(correlations[,2])),1] # saves the locations of OH and OL
origins<-as.numeric(c(substr(location,start=regexpr("OH",location)+2,stop=regexpr("OL",location)-1),substr(location,start=regexpr("OL",location)+2,stop=nchar(location))))
# in the paper, they analyzed the H strand but needed to return coordinates on the L strand, so I assume that I must switch the values in the end to get correct coordinates
#summarize results
names(origins)<-c("OL","OH")
print(alignment[1])
print(paste0("OH: ",origins[2]," OL: ",origins[1]))
return(c(origins[2],origins[1]))
# } #end of iteration over sequences, see lines just below data loading
} # end of function
for(i in seq(151,351,by=10)){
results<-rbind(results,replication_origin(alignment,i))
}
mean(results[,1])
mean(results[,2])
alignment<-read.table("origin.fas",header=F)
for(i in seq(151,351,by=10)){
results<-rbind(results,replication_origin(alignment,i))
}
View(results)
hist(results[,1])
hist(results[,2])
hist(results[,2],5)
hist(results[,2],10)
hist(results[,1],10)
library(devtools)
load_all()
a<-representative.alignment(level="subclade",genes=c("COX1,16S,12S_TRNM"))
a<-representative.alignment(level="subclade",genes=c("COX1,16S,12S_TRNM"),weight="max")
a<-representative.alignment(level="subclade",genes=c("COX1","16S","12S_TRNM"),weight="max")
library(devtools)
load_all()
a<-representative.alignment(level="clade",genes=c("COX1","16S","12S_TRNM"),weight="max")
a<-representative.alignment(level="ID",genes=c("COX1","16S","12S_TRNM"),weight="max")
a<-representative.alignment(level="subclade",genes=c("COX1","16S","12S_TRNM"),weight="max")
a<-representative.alignment(level="clade",genes=c("COX1","16S","12S_TRNM"),weight="max")
a<-representative.alignment(level="ID",genes=c("COX1","16S","12S_TRNM"),weight="max")
a<-representative.alignment(level="ID",individuals=c("HE003273", "HE003274", "HE003275", "HE003276", "HE003277", "HE002644", "HE003132", "HE001286", "HE001246", "HE003254", "HE003253", "HE000505", "HE002946", "HE003257", "HE003148", "HE003251", "HE000808", "HE001725", "HE002405", "HE000991", "HE002487"),weight="max",maxloci=FALSE,file ="mitogenomes_genbank.fas")
a<-representative.alignment(level="ID",individuals=c("HE003273", "HE003274", "HE003275", "HE003276", "HE003277", "HE002644", "HE003132", "HE001286", "HE001246", "HE003254", "HE003253", "HE000505", "HE002946", "HE003257", "HE003148", "HE003251", "HE000808", "HE001725", "HE002405", "HE000991", "HE002487","HE003272","HE003268","HE002964","HE001273","HE002954","HE002865","HE002843","HE002600","HE001338","HE001230","HE002250","HE002944"),weight="max",maxloci=FALSE,file ="mitogenomes_genbank.fas")
exportfile="genbank_5column_features.txt"
gff<-read.table(file="240731_mitogenome_annotations.gff",header=FALSE,sep="\t")
setwd("~/helix-clanek/aktualni-data/Helicini_Hamburg_2021-2023/mitoHelicini")
exportfile="genbank_5column_features.txt"
gff<-read.table(file="240731_mitogenome_annotations.gff",header=FALSE,sep="\t")
setwd("~/helix-clanek/aktualni-data/Helicini_Hamburg_2021-2023")
exportfile="genbank_5column_features.txt"
gff<-read.table(file="240731_mitogenome_annotations.gff",header=FALSE,sep="\t")
#change to your desired filename
c9<-unlist(sapply(gff[,9,drop=TRUE],FUN=function(x){
pattern <- "name=\\s*(.*?)\\s*;"
regmatches(x,regexec(pattern, x))[[1]][2]
}))
c10<-unlist(sapply(gff[,9,drop=TRUE],FUN=function(x){
pattern <- "note=\\s*(.*?)\\s*;"
regmatches(x,regexec(pattern, x))[[1]][2]
}))
gff[,9]<-c9
gff[,10]<-c10
previous_seq<-""
product.table<-read.table("features_translate_table.txt",header=FALSE,sep="\t",text=)
for(i in 1:length(gff[,1,drop=TRUE])){
#assuming that only features that are labeled as current are to be included in the submission
if(gff[i,1]!=previous_seq&gff[i,2]=="current"){
cat("\n",">Feature ","\t",gff[i,1],sep="",append=TRUE,file=exportfile) ##### opravit, dádvá tabulator na konec radku
previous_seq<-gff[i,1]
}
#in case the feature is CDS (there are two possible orientations, thus the two ifs, the first distinguishes genes with incomplete stop)
if(gff[i,3]=="CDS"&gff[i,2]=="current"){
if(gff[i,7]=="+"){
cat("\n",gff[i,4],"\t",gff[i,5],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,4],"\t",gff[i,5],"\t","CDS",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","transl_table","\t","5",sep="",append=TRUE,file=exportfile)
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","transl_except","\t","(pos:",gff[i,5],",aa:TERM)",sep="",append=TRUE,file=exportfile)}
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","note","\t","TAA stop codon is completed by the addition of 3' A residues to the mRNA",sep="",append=TRUE,file=exportfile)}
}
if(gff[i,7]=="-"){
cat("\n",gff[i,5],"\t",gff[i,4],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,5],"\t",gff[i,4],"\t","CDS",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","transl_table","\t","5",sep="",append=TRUE,file=exportfile)
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","transl_except","\t","(pos:",gff[i,4],",aa:TERM)",sep="",append=TRUE,file=exportfile)}
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","note","\t","TAA stop codon is completed by the addition of 3' A residues to the mRNA",sep="",append=TRUE,file=exportfile)}
}
}
#in case the feature is tRNA (there are two possible orientations, thus the two ifs)
if(gff[i,3]=="tRNA"&gff[i,2]=="current"){
if(gff[i,7]=="+"){
cat("\n",paste(gff[i,4],gff[i,5],"gene",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",paste(gff[i,4],gff[i,5],"tRNA",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
if(gff[i,7]=="-"){
cat("\n",paste(gff[i,5],gff[i,4],"gene",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",paste(gff[i,5],gff[i,4],"tRNA",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
}
#in case the feature is rRNA (there are two possible orientations, thus the two ifs)
if(gff[i,3]=="rRNA"&gff[i,2]=="current"){
if(grepl("rrnS",gff[i,9])==TRUE){
x<-">"
}else{
x<-""
}
if(gff[i,7]=="+"){
cat("\n",gff[i,4],"\t",x,gff[i,5],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,4],"\t",x,gff[i,5],"\t","rRNA",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
if(gff[i,7]=="-"){
cat("\n",gff[i,5],"\t",x,gff[i,4],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,5],"\t",x,gff[i,4],"\t","rRNA",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
}
}
c9<-unlist(sapply(gff[,9,drop=TRUE],FUN=function(x){
pattern <- "name=\\s*(.*?)\\s*;"
regmatches(x,regexec(pattern, x))[[1]][2]
}))
c10<-unlist(sapply(gff[,9,drop=TRUE],FUN=function(x){
pattern <- "note=\\s*(.*?)\\s*;"
regmatches(x,regexec(pattern, x))[[1]][2]
}))
gff[,9]<-c9
gff[,10]<-c10
previous_seq<-""
product.table<-read.table("features_translate_table.txt",header=FALSE,sep="\t",text=)
for(i in 1:length(gff[,1,drop=TRUE])){
#assuming that only features that are labeled as current are to be included in the submission
if(gff[i,1]!=previous_seq&gff[i,2]=="current"){
cat("\n",">Feature ","\t",gff[i,1],sep="",append=TRUE,file=exportfile) ##### opravit, dádvá tabulator na konec radku
previous_seq<-gff[i,1]
}
#in case the feature is CDS (there are two possible orientations, thus the two ifs, the first distinguishes genes with incomplete stop)
if(gff[i,3]=="CDS"&gff[i,2]=="current"){
if(gff[i,7]=="+"){
cat("\n",gff[i,4],"\t",gff[i,5],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,4],"\t",gff[i,5],"\t","CDS",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","transl_table","\t","5",sep="",append=TRUE,file=exportfile)
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","transl_except","\t","(pos:",gff[i,5],",aa:TERM)",sep="",append=TRUE,file=exportfile)}
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","note","\t","TAA stop codon is completed by the addition of 3' A residues to the mRNA",sep="",append=TRUE,file=exportfile)}
}
if(gff[i,7]=="-"){
cat("\n",gff[i,5],"\t",gff[i,4],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,5],"\t",gff[i,4],"\t","CDS",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","transl_table","\t","5",sep="",append=TRUE,file=exportfile)
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","transl_except","\t","(pos:",gff[i,4],",aa:TERM)",sep="",append=TRUE,file=exportfile)}
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","note","\t","TAA stop codon is completed by the addition of 3' A residues to the mRNA",sep="",append=TRUE,file=exportfile)}
}
}
#in case the feature is tRNA (there are two possible orientations, thus the two ifs)
if(gff[i,3]=="tRNA"&gff[i,2]=="current"){
if(gff[i,7]=="+"){
cat("\n",paste(gff[i,4],gff[i,5],"gene",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",paste(gff[i,4],gff[i,5],"tRNA",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
if(gff[i,7]=="-"){
cat("\n",paste(gff[i,5],gff[i,4],"gene",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",paste(gff[i,5],gff[i,4],"tRNA",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
}
#in case the feature is rRNA (there are two possible orientations, thus the two ifs)
if(gff[i,3]=="rRNA"&gff[i,2]=="current"){
if(grepl("rrnS",gff[i,9])==TRUE){
x<-">"
}else{
x<-""
}
if(gff[i,7]=="+"){
cat("\n",gff[i,4],"\t",x,gff[i,5],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,4],"\t",x,gff[i,5],"\t","rRNA",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
if(gff[i,7]=="-"){
cat("\n",gff[i,5],"\t",x,gff[i,4],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,5],"\t",x,gff[i,4],"\t","rRNA",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
}
}
View(product.table)
i<-1
if(gff[i,1]!=previous_seq&gff[i,2]=="current"){
cat("\n",">Feature ","\t",gff[i,1],sep="",append=TRUE,file=exportfile) ##### opravit, dádvá tabulator na konec radku
previous_seq<-gff[i,1]
}
cat("\n",gff[i,4],"\t",gff[i,5],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
which(product.table[,1,drop=TRUE]==gff[i,9]
)
gff[i,9]
View(gff)
c9<-unlist(sapply(gff[,9,drop=TRUE],FUN=function(x){
pattern <- "name=\\s*(.*?)\\s*;"
regmatches(x,regexec(pattern, x))[[1]][2]
}))
c10<-unlist(sapply(gff[,9,drop=TRUE],FUN=function(x){
pattern <- "note=\\s*(.*?)\\s*;"
regmatches(x,regexec(pattern, x))[[1]][2]
}))
gff[,9]<-c9
gff[,10]<-c10
View(gff)
gff<-read.table(file="240731_mitogenome_annotations.gff",header=FALSE,sep="\t")
#change to your desired filename
c9<-unlist(sapply(gff[,9,drop=TRUE],FUN=function(x){
pattern <- "name=\\s*(.*?)\\s*;"
regmatches(x,regexec(pattern, x))[[1]][2]
}))
c10<-unlist(sapply(gff[,9,drop=TRUE],FUN=function(x){
pattern <- "note=\\s*(.*?)\\s*;"
regmatches(x,regexec(pattern, x))[[1]][2]
}))
gff[,9]<-c9
gff[,10]<-c10
View(gff)
gff1<-gff[-(1:25),]
View(gff1)
gff<-gff1
previous_seq<-""
product.table<-read.table("features_translate_table.txt",header=FALSE,sep="\t",text=)
for(i in 1:length(gff[,1,drop=TRUE])){
#assuming that only features that are labeled as current are to be included in the submission
if(gff[i,1]!=previous_seq&gff[i,2]=="current"){
cat("\n",">Feature ","\t",gff[i,1],sep="",append=TRUE,file=exportfile) ##### opravit, dádvá tabulator na konec radku
previous_seq<-gff[i,1]
}
#in case the feature is CDS (there are two possible orientations, thus the two ifs, the first distinguishes genes with incomplete stop)
if(gff[i,3]=="CDS"&gff[i,2]=="current"){
if(gff[i,7]=="+"){
cat("\n",gff[i,4],"\t",gff[i,5],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,4],"\t",gff[i,5],"\t","CDS",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","transl_table","\t","5",sep="",append=TRUE,file=exportfile)
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","transl_except","\t","(pos:",gff[i,5],",aa:TERM)",sep="",append=TRUE,file=exportfile)}
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","note","\t","TAA stop codon is completed by the addition of 3' A residues to the mRNA",sep="",append=TRUE,file=exportfile)}
}
if(gff[i,7]=="-"){
cat("\n",gff[i,5],"\t",gff[i,4],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,5],"\t",gff[i,4],"\t","CDS",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","transl_table","\t","5",sep="",append=TRUE,file=exportfile)
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","transl_except","\t","(pos:",gff[i,4],",aa:TERM)",sep="",append=TRUE,file=exportfile)}
if(grepl("stop T--",gff[i,10])==TRUE){cat("\n","\t","\t","\t","note","\t","TAA stop codon is completed by the addition of 3' A residues to the mRNA",sep="",append=TRUE,file=exportfile)}
}
}
#in case the feature is tRNA (there are two possible orientations, thus the two ifs)
if(gff[i,3]=="tRNA"&gff[i,2]=="current"){
if(gff[i,7]=="+"){
cat("\n",paste(gff[i,4],gff[i,5],"gene",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",paste(gff[i,4],gff[i,5],"tRNA",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
if(gff[i,7]=="-"){
cat("\n",paste(gff[i,5],gff[i,4],"gene",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",paste(gff[i,5],gff[i,4],"tRNA",collapse="",sep="\t"),sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
}
#in case the feature is rRNA (there are two possible orientations, thus the two ifs)
if(gff[i,3]=="rRNA"&gff[i,2]=="current"){
if(grepl("rrnS",gff[i,9])==TRUE){
x<-">"
}else{
x<-""
}
if(gff[i,7]=="+"){
cat("\n",gff[i,4],"\t",x,gff[i,5],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,4],"\t",x,gff[i,5],"\t","rRNA",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
if(gff[i,7]=="-"){
cat("\n",gff[i,5],"\t",x,gff[i,4],"\t","gene",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","gene","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),2],sep="",append=TRUE,file=exportfile)
cat("\n",gff[i,5],"\t",x,gff[i,4],"\t","rRNA",sep="",append=TRUE,file=exportfile)
cat("\n","\t","\t","\t","product","\t",product.table[which(product.table[,1,drop=TRUE]==gff[i,9]),3],sep="",append=TRUE,file=exportfile)
if(is.na(gff[i,10])==FALSE){cat("\n","\t","\t","\t","note","\t",gff[i,10],sep="",append=TRUE,file=exportfile)}
}
}
}
########### now you must manually change CDS end coordinates in PCGs where stop is followed by additional nucleotides!!!
setwd("~/helix-clanek/aktualni-data/Helicini_Hamburg_2021-2023/mitoHelicini")
a<-representative.alignment(level="ID",individuals=c("HE003273", "HE003274", "HE003275", "HE003276", "HE003277", "HE002644", "HE003132", "HE001286", "HE001246", "HE003254", "HE003253", "HE000505", "HE002946", "HE003257", "HE003148", "HE003251", "HE000808", "HE001725", "HE002405", "HE000991", "HE002487","HE003272","HE003268","HE002964","HE001273","HE002954","HE002865","HE002843","HE002600","HE001338","HE001230","HE002250","HE002944"),weight="max",maxloci=FALSE,file ="mitogenomes_genbank.fas")
a<-representative.alignment(level="ID",individuals=c("HE003273", "HE003274", "HE003275", "HE003276", "HE003277", "HE002644", "HE003132", "HE001286", "HE001246", "HE003254", "HE003253", "HE000505", "HE002946", "HE003257", "HE003148", "HE003251", "HE000808", "HE001725", "HE002405", "HE000991", "HE002487","HE003272","HE003268","HE002964","HE001273","HE002954","HE002865","HE002843","HE002600","HE001338","HE001230","HE002250","HE002944"),weight="max",maxloci=FALSE,file ="mitogenomes_genbank.fas")
paste0(rep("n",100),collapse="")
paste0(rep("N",100),collapse="")
library(devtools)
load_all()
a<-representative.alignment(level="ID",individuals=c("HE000394"),weight="max",maxloci=FALSE,file ="mitogenome_POM.fas")
a<-representative.alignment(level="ID",individuals=c("HE003273", "HE003274", "HE003275", "HE003276", "HE003277", "HE002644", "HE003132", "HE001286", "HE001246", "HE003254", "HE003253", "HE000505", "HE002946", "HE003257", "HE003148", "HE003251", "HE000808", "HE001725", "HE002405", "HE000991", "HE002487","HE003272","HE003268","HE002964","HE001273","HE002954","HE002865","HE002843","HE002600","HE001338","HE001230","HE002250","HE002944","HE000394"),weight="max",maxloci=FALSE,file ="mitogenomes_genbank.fas")
library(devtools)
load_all()
a<-representative.alignment(level="ID",genes=c("COX1","16S","12S"),individuals=c("HE000548","HE002392","HE000577","HE001239","HE001241","HE002954","HE002541","HE002542","HE003012","HE003062","HE003094","HE003105","HE002995","HE001276","HE001275","HE000625","HE0TH215","HE000094","HE000150","HE003200","HE000221","HE000799","HE000575","HE000785","HE003117","HE002332","HE003128","HE000557","HE003129","HE003132","HE001338","HE002865","HE002139","HE001257","HE003126","HE003127","HE002652","HE002405","HE001273","HE001207","HE000717","HE002404","HE002600","HE002637","HE002843","HE002964","HE001196","HE003268","HE000505","HE000808","HE001725","HE002946","HE003257","HE003275","HE003273","HE003276","HE003277","HE003274","HE001230","HE002644"),weight="max",maxloci=FALSE,file ="ddRAD_3_genes.fas")
a<-representative.alignment(level="ID",genes=c("COX1","16S","12S"),individuals=c("HE000548","HE002392","HE000577","HE001239","HE001241","HE002954","HE002541","HE002542","HE003012","HE003062","HE003094","HE003105","HE002995","HE001276","HE001275","HE000625","HE0TH215","HE000094","HE000150","HE003200","HE000221","HE000799","HE000575","HE000785","HE003117","HE002332","HE003128","HE000557","HE003129","HE003132","HE001338","HE002865","HE002139","HE001257","HE003126","HE003127","HE002652","HE002405","HE001273","HE001207","HE000717","HE002404","HE002600","HE002637","HE002843","HE002964","HE001196","HE003268","HE000505","HE000808","HE001725","HE002946","HE003257","HE003275","HE003273","HE003276","HE003277","HE003274","HE001230","HE002644","HE003251"),weight="max",maxloci=FALSE,file ="ddRAD_3_genes.fas")
